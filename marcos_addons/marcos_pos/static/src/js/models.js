function marcos_pos_models(instance, module) {

    var _t = instance.web._t;
    var round_pr = instance.web.round_precision;
    var round_di = instance.web.round_decimals;

    /**
     * @param funcName
     * @returns {*}
     * @private
     */
    Backbone.Model.prototype._super = function (funcName) {
        var scope = null;
        var scan = this.__proto__;
        search: while (scope == null && scan != null) {
            var names = Object.getOwnPropertyNames(scan);
            for (var i = 0; i < names.length; i++) {
                if (scan[names[i]] === arguments.callee.caller) {
                    scope = scan;
                    break search;
                }
            }
            scan = scan.constructor.__super__;
        }
        return scan.constructor.__super__[funcName].apply(this, _.rest(arguments));
    };

    module.PosModel = module.PosModel.extend({
        initialize: function (session, attributes) {
            this._super('initialize', session, attributes);
            this.pricelist_engine = new module.PricelistEngine({
                'pos': this,
                'db': this.db,
                'pos_widget': this.pos_widget
            });
            this.type = attributes.type;
            this.manager = false;
            this.manger_permission = false;
            this.user_before_manager = false;
            this.manger_validated = false;
            arrange_elements(this);
        },
        add_new_order: function (type) {
            var order = new module.Order({pos: this, type: type});
            this.get('orders').add(order);
            this.set('selectedOrder', order);
        },
        find_model: function (model_name) {
            var self = this;
            var lookup = {};
            for (var i = 0, len = self.models.length; i < len; i++) {
                if (self.models[i].model === model_name) {
                    lookup[i] = self.models[i]
                }
            }
            return lookup
        },
        on_removed_order: function (removed_order, index, reason) {
            this._super('on_removed_order', removed_order, index, reason);
            if ((reason === 'abandon' || removed_order.temporary) && this.get('orders').size() > 0) {
                var current_order = (this.get('orders').at(index) || this.get('orders').last());
                var partner = current_order.get_client() ? current_order.get_client() : false;
                this.pricelist_engine.update_products_ui(partner);
            }
        },

        push_and_quotation_order: function (order, action) {
            var self = this;
            var invoiced = new $.Deferred();

            if (!order.get_client()) {
                invoiced.reject('error-no-client');
                return invoiced;
            }

            var order_id = order.export_as_JSON();

            this.flush_mutex.exec(function () {
                var done = new $.Deferred(); // holds the mutex

                var posOrderModel = new instance.web.Model('pos.order');
                var transfer = posOrderModel.call("action_quotation", [order_id], {"context": {"action": action}});

                transfer.fail(function () {
                    invoiced.reject('error-transfer');
                    done.reject();
                });

                // on success, get the order id generated by the server
                transfer.pipe(function (order_server_id) {
                    self.pos_widget.do_action(order_server_id);
                    invoiced.resolve();
                    done.resolve();
                });
                return done;

            });

            return invoiced;
        },

        // server generated ids for the sent orders
        _save_to_server: function (orders, options) {

            if (!orders || !orders.length) {
                var result = $.Deferred();
                result.resolve([]);
                return result;
            }

            options = options || {};

            var self = this;
            var timeout = typeof options.timeout === 'number' ? options.timeout : 107500 * orders.length;

            var currentOrder = self.get('selectedOrder');
            // we try to send the order. shadow prevents a spinner if it takes too long. (unless we are sending an invoice,
            // then we want to notify the user that we are waiting on something )
            var posOrderModel = new instance.web.Model('pos.order');
            return posOrderModel.call('create_from_ui',
                [_.map(orders, function (order) {
                    order.to_invoice = options.to_invoice || false;
                    return order;
                })],
                undefined
                //{
                //    shadow: !options.to_invoice,
                //    timeout: timeout
                //}
            ).then(function (server_ids) {
                new instance.web.Model("pos.order").call("get_ncf_info", [currentOrder.uid], undefined)
                    .then(function (result) {

                        currentOrder.set("ncf_type", result.ncf_type);
                        currentOrder.set("ncf", result.ncf);

                        if (self.config.ipf_printer === true) {
                            _.each(server_ids, function (order_id) {
                                var context = new instance.web.CompoundContext({
                                    active_model: "pos.order",
                                    active_id: order_id
                                });
                                new openerp.web.Model("ipf.printer.config").call("ipf_print", [], {context: context})
                                    .then(function (data) {
                                        currentOrder.destroy();    //finish order and go back to scan screen
                                        self.print_on_ipf(data, result.ncf)
                                    });
                            });
                        }
                        else if (self.config.iface_print_via_proxy) {
                            var receipt = currentOrder.export_for_printing();
                            this.pos.proxy.print_receipt(QWeb.render('XmlReceipt', {
                                receipt: receipt, widget: self,
                            }));
                            currentOrder.destroy();    //finish order and go back to scan screen
                        } else {
                            self.pos_widget.screen_selector.set_current_screen("receipt");
                        }

                    });

                _.each(orders, function (order) {
                    self.db.remove_order(order.id);
                });

                return server_ids;
            }).fail(function (error, event) {
                if (error.code === 200) {    // Business Logic Error, not a connection problem
                    self.pos_widget.screen_selector.show_popup('error-traceback', {
                        message: error.data.message,
                        comment: error.data.debug
                    });
                }
                // prevent an error popup creation by the rpc failure
                // we want the failure to be silent as we send the orders in the background
                event.preventDefault();
                console.error('Failed to send orders:', orders);
                if (self.config.ipf_printer === true) {
                    var receipt = currentOrder.export_for_printing();
                    self.print_on_ipf(receipt, "nofiscal");
                    currentOrder.destroy()
                }
                else if (self.config.iface_print_via_proxy) {
                    var receipt = currentOrder.export_for_printing();
                    this.pos.proxy.print_receipt(QWeb.render('XmlReceipt', {
                        receipt: receipt, widget: self,
                    }));
                    this.pos.get('selectedOrder').destroy();    //finish order and go back to scan screen
                } else {
                    self.pos_widget.screen_selector.set_current_screen("receipt");
                }
            });
        },
        print_on_ipf_done: function () {
            var self = this;
            return new openerp.web.Model("ipf.printer.config").call("print_done", [[self.invoice_id, self.nif]], {context: new instance.web.CompoundContext()})
                .then(function (response) {
                    return response;
                })
        },
        print_on_ipf: function (data, ncf) {
            var self = this;

            if (ncf === "nofiscal") {
                data = {
                    "cashier": self.user.id,
                    "client": data.client,
                    "copy": false,
                    "host": self.config.ipf_ip,
                    "invoice_id": false,
                    "items": [{
                        "description": "250g Lays Pickels",
                        "itbis": 18,
                        "price": 1.7464,
                        "quantity": 1.0
                    }],
                    "ncf": "",
                    "payments": [{"amount": 1.75, "type": "Check"}],
                    "rnc": "",
                    "subsidiary": 1,
                    "type": "nofiscal"
                }

            }

            this.invoice_id = data.invoice_id;
            $.ajax({
                    type: 'POST',
                    url: data.host + "/invoice",
                    data: JSON.stringify(data)
                })
                .done(function (response) {
                    var message = JSON.parse(response);
                    self.get('selectedOrder').destroy();
                    self.nif = message.response.nif;
                    self.print_on_ipf_done();
                })
                .fail(function (response) {

                    try {
                        console.log(response);
                        var message = JSON.parse(response.responseText) || {message: ""};
                        if (message.message === "Missing payment type.") {
                            return alert("Los tipos de pagos para la impresora fiscal, debe de configurarlos en los diarios de pago.")
                        } else if (message.message === "Payment incomplete.") {
                            return alert("Debe actualizar el total de factura en el botón actualizar al que se encuenta al lado del total.")
                        } else if (message.message === "The printer is not connected.") {
                            return alert("El sistenma no puede comunicarse con la impresora.")
                        }
                    } catch (err) {
                        console.log(self);
                        self.get('selectedOrder').destroy();
                        self.pos_widget.screen_selector.show_popup('error', {
                            'message': 'Ocurrio un error al intentar imprimir en la impresora fiscal',
                            'comment': 'No se pudo imprimir la factura por un problema de conexion con la impresora!.'
                        });
                    }

                });
        },
        validate_user: function (value) {
            var self = this;
            var fast_login = false;

            _.each(self.users, function (user) {
                if (user.short_pwd === value) {
                    self.user_before_manager = self.user.id;
                    self.barcode_reader.scan(user.ean13);
                    self.manager = user.id;
                    fast_login = true;
                }
            });

            if (fast_login) {
                $(".username").css("color", "#269DB4").css("font-size", "30px");
                return
            } else {
                return self.pos_widget.change_user();
            }
        },
        validate_manager: function () {
            var self = this;
            self.manger_validated = false;
            var managers = self.pos_manager;
            if (managers) {
                _.each(managers, function (manager) {
                    _.each(manager.users, function (user) {
                        if (self.manager === user) {
                            self.manger_permission = manager;
                            self.manger_validated = true;
                            return
                        }
                    })
                });
            }
        },
        models: [
            {
                model: 'res.users',
                fields: ['name', 'company_id'],
                ids: function (self) {
                    return [self.session.uid];
                },
                loaded: function (self, users) {
                    self.user = users[0];
                }
            }, {
                model: 'pos.manager',
                fields: ["name", "max_disc", "change_price", "refund", "cash_refund", "users"],
                domain: null,
                loaded: function (self, pos_manager) {
                    self.pos_manager = pos_manager;
                }

            }, {
                model: 'res.company',
                fields: ['currency_id', 'email', 'website', 'company_registry', 'vat',
                    'name', 'phone', 'fax', 'partner_id', 'country_id', 'city', 'state_id', 'street', 'street2'],
                ids: function (self) {
                    return [self.user.company_id[0]]
                },
                loaded: function (self, companies) {
                    self.company = companies[0];
                }
            }, {
                model: 'decimal.precision',
                fields: ['name', 'digits'],
                loaded: function (self, dps) {
                    self.dp = {};
                    for (var i = 0; i < dps.length; i++) {
                        self.dp[dps[i].name] = dps[i].digits;
                    }
                }
            }, {
                model: 'product.uom',
                fields: [],
                domain: null,
                loaded: function (self, units) {
                    self.units = units;
                    var units_by_id = {};
                    for (var i = 0, len = units.length; i < len; i++) {
                        units_by_id[units[i].id] = units[i];
                        units[i].groupable = ( units[i].category_id[0] === 1 );
                        units[i].is_unit = ( units[i].id === 1 );
                    }
                    self.units_by_id = units_by_id;
                }
            }, {
                model: 'res.users',
                fields: ['name', 'ean13', 'short_pwd'],
                domain: null,
                loaded: function (self, users) {
                    self.users = users;
                }
            }, {
                model: 'res.partner',
                fields: ['name', 'street', 'city', 'state_id', 'country_id', 'ref', 'phone', 'zip', 'mobile', 'email', 'ean13', 'write_date'],
                domain: [['customer', '=', true]],
                loaded: function (self, partners) {
                    self.partners = partners;
                    self.db.add_partners(partners);
                }
            }, {
                model: 'res.country',
                fields: ['name'],
                loaded: function (self, countries) {
                    self.countries = countries;
                    self.company.country = null;
                    for (var i = 0; i < countries.length; i++) {
                        if (countries[i].id === self.company.country_id[0]) {
                            self.company.country = countries[i];
                        }
                    }
                }
            }, {
                model: 'account.tax',
                fields: ['name', 'amount', 'price_include', 'include_base_amount', 'type'],
                domain: null,
                loaded: function (self, taxes) {
                    self.taxes = taxes;
                    self.taxes_by_id = {};
                    for (var i = 0; i < taxes.length; i++) {
                        self.taxes_by_id[taxes[i].id] = taxes[i];
                    }
                }
            }, {
                model: 'pos.session',
                fields: ['id', 'journal_ids', 'name', 'user_id', 'config_id', 'start_at', 'stop_at', 'sequence_number', 'login_number'],
                domain: function (self) {
                    return [['state', '=', 'opened'], ['user_id', '=', self.session.uid]];
                },
                loaded: function (self, pos_sessions) {
                    self.pos_session = pos_sessions[0];

                    var orders = self.db.get_orders();
                    for (var i = 0; i < orders.length; i++) {
                        self.pos_session.sequence_number = Math.max(self.pos_session.sequence_number, orders[i].data.sequence_number + 1);
                    }
                }
            }, {
                model: 'pos.config',
                fields: [],
                domain: function (self) {
                    return [['id', '=', self.pos_session.config_id[0]]];
                },
                loaded: function (self, configs) {
                    self.config = configs[0];
                    self.config.use_proxy = self.config.iface_payment_terminal ||
                        self.config.iface_electronic_scale ||
                        self.config.iface_print_via_proxy ||
                        self.config.iface_scan_via_proxy ||
                        self.config.iface_cashdrawer;

                    self.barcode_reader.add_barcode_patterns({
                        'product': self.config.barcode_product,
                        'cashier': self.config.barcode_cashier,
                        'client': self.config.barcode_customer,
                        'weight': self.config.barcode_weight,
                        'discount': self.config.barcode_discount,
                        'price': self.config.barcode_price
                    });

                    if (self.config.company_id[0] !== self.user.company_id[0]) {
                        throw new Error(_t("Error: The Point of Sale User must belong to the same company as the Point of Sale. You are probably trying to load the point of sale as an administrator in a multi-company setup, with the administrator account set to the wrong company."));
                    }
                }
            }, {
                model: 'stock.location',
                fields: [],
                ids: function (self) {
                    return [self.config.stock_location_id[0]];
                },
                loaded: function (self, locations) {
                    self.shop = locations[0];
                }
            }, {
                model: 'product.pricelist',
                fields: ['currency_id'],
                ids: function (self) {
                    return [self.config.pricelist_id[0]];
                },
                loaded: function (self, pricelists) {
                    self.pricelist = pricelists[0];
                }
            }, {
                model: 'res.currency',
                fields: ['symbol', 'position', 'rounding', 'accuracy'],
                ids: function (self) {
                    return [self.pricelist.currency_id[0]];
                },
                loaded: function (self, currencies) {
                    self.currency = currencies[0];
                    if (self.currency.rounding > 0) {
                        self.currency.decimals = Math.ceil(Math.log(1.0 / self.currency.rounding) / Math.log(10));
                    } else {
                        self.currency.decimals = 0;
                    }

                }
            }, {
                model: 'product.packaging',
                fields: ['ean', 'product_tmpl_id'],
                domain: null,
                loaded: function (self, packagings) {
                    self.db.add_packagings(packagings);
                }
            }, {
                model: 'pos.category',
                fields: ['id', 'name', 'parent_id', 'child_id', 'image'],
                domain: null,
                loaded: function (self, categories) {
                    self.db.add_categories(categories);
                }
            }, {
                model: 'product.product',
                fields: ['display_name', 'list_price', 'price', 'pos_categ_id', 'taxes_id', 'ean13', 'default_code',
                    'to_weight', 'uom_id', 'uos_id', 'uos_coeff', 'mes_type', 'description_sale', 'description',
                    'product_tmpl_id'],
                domain: [['sale_ok', '=', true], ['available_in_pos', '=', true]],
                context: function (self) {
                    return {pricelist: self.pricelist.id, display_default_code: false};
                },
                loaded: function (self, products) {
                    self.db.add_products(products);
                }
            }, {
                model: 'account.bank.statement',
                fields: ['account_id', 'currency', 'journal_id', 'state', 'name', 'user_id', 'pos_session_id'],
                domain: function (self) {
                    return [['state', '=', 'open'], ['pos_session_id', '=', self.pos_session.id]];
                },
                loaded: function (self, bankstatements, tmp) {
                    self.bankstatements = bankstatements;

                    tmp.journals = [];
                    _.each(bankstatements, function (statement) {
                        tmp.journals.push(statement.journal_id[0]);
                    });
                }
            },
            {
                model: 'account.journal',
                fields: [],
                domain: function (self, tmp) {
                    return [['id', 'in', tmp.journals]];
                },
                loaded: function (self, journals) {
                    self.journals = journals;

                    // associate the bank statements with their journals.
                    var bankstatements = self.bankstatements;
                    for (var i = 0, ilen = bankstatements.length; i < ilen; i++) {
                        for (var j = 0, jlen = journals.length; j < jlen; j++) {
                            if (bankstatements[i].journal_id[0] === journals[j].id) {
                                bankstatements[i].journal = journals[j];
                            }
                        }
                    }
                    self.cashregisters = bankstatements;
                }
            }, {
                label: 'fonts',
                loaded: function (self) {
                    var fonts_loaded = new $.Deferred();

                    // Waiting for fonts to be loaded to prevent receipt printing
                    // from printing empty receipt while loading Inconsolata
                    // ( The font used for the receipt )
                    waitForWebfonts(['Lato', 'Inconsolata'], function () {
                        fonts_loaded.resolve();
                    });

                    // The JS used to detect font loading is not 100% robust, so
                    // do not wait more than 5sec
                    setTimeout(function () {
                        fonts_loaded.resolve();
                    }, 5000);

                    return fonts_loaded;
                }
            }, {
                label: 'pictures',
                loaded: function (self) {
                    self.company_logo = new Image();
                    var logo_loaded = new $.Deferred();
                    self.company_logo.onload = function () {
                        var img = self.company_logo;
                        var ratio = 1;
                        var targetwidth = 300;
                        var maxheight = 150;
                        if (img.width !== targetwidth) {
                            ratio = targetwidth / img.width;
                        }
                        if (img.height * ratio > maxheight) {
                            ratio = maxheight / img.height;
                        }
                        var width = Math.floor(img.width * ratio);
                        var height = Math.floor(img.height * ratio);
                        var c = document.createElement('canvas');
                        c.width = width;
                        c.height = height
                        var ctx = c.getContext('2d');
                        ctx.drawImage(self.company_logo, 0, 0, width, height);

                        self.company_logo_base64 = c.toDataURL();
                        logo_loaded.resolve();
                    };
                    self.company_logo.onerror = function () {
                        logo_loaded.reject();
                    };
                    self.company_logo.crossOrigin = "anonymous";
                    self.company_logo.src = '/web/binary/company_logo' + '?_' + Math.random();

                    return logo_loaded;
                }
            },
        ]
    });

    module.Order = module.Order.extend({
        /**
         * override this method to merge lines
         * @param product
         * @param options
         */
        set_remaining: function (value) {
            this.set("remaining", value);
        },
        get_remaining: function () {
            return this.has('remaining') ? this.get('remaining') : "0";
        },
        set_credit_note_ncf: function (ncf) {
            this.set("credit_note_ncf", ncf);
        },
        get_credit_note_ncf: function () {
            return this.has('credit_note_ncf') ? this.get('credit_note_ncf') : false;
        },
        set_credit_paid: function (credit_paid) {
            this.set('credit_paid', credit_paid);
        },
        get_credit_paid: function () {
            return this.has('credit_paid') ? this.get('credit_paid') : 0.00;
        },
        getChange: function () {
            return (this.getPaidTotal() + this.get_credit_paid()) - this.getTotalTaxIncluded();
        },
        getDueLeft: function () {
            return this.getTotalTaxIncluded() - (this.getPaidTotal() + this.get_credit_paid());
        },
        addProduct: function (product, options) {
            options = options || {};
            var self = this;
            /**
             * Check first if product come from refund
             * @type {boolean}
             */
            var type = false;
            var refund_order_id = false;
            var add_prod = true;
            if (this.has("type") && this.has("refund_order_id")) {
                type = this.get("type");
                refund_order_id = this.get("refund_order_id");
            }
            if (type === "refund") {
                this.get('orderLines').each(_.bind(function (item) {
                    if (product.id === item.product.id && product.qty_available === item.quantity) {
                        self.pos.pos_widget.screen_selector.show_popup('error', {
                            message: _t('Advertencia!'),
                            comment: _t('No puede devolver mas productos.')
                        });
                        add_prod = false;
                    }
                }))
            }

            if (add_prod) {

                var attr = JSON.parse(JSON.stringify(product));
                attr.pos = this.pos;
                attr.order = this;
                var line = new module.Orderline({}, {pos: this.pos, order: this, product: product});
                var self = this;
                var found = false;

                if (options.quantity !== undefined) {
                    line.set_quantity(options.quantity);
                }

                if (type === "refund") {
                    console.log("=======options.refund_price=========")
                    console.log(options.refund_price)
                    console.log(product.refund_price)
                    console.log("================")
                    line.set_unit_price(product.refund_price);
                } else if (options.price !== undefined) {
                    line.set_unit_price(options.price);
                }

                if (type === "refund") {
                    console.log("================")
                    console.log(options.refund_discount)
                    console.log(product.refund_discount)
                    console.log("================")
                    line.set_discount(product.refund_discount);
                } else if (options.discount !== undefined) {
                    line.set_discount(options.discount);
                }

                var orderlines = [];
                if (self.get('orderLines').models !== undefined) {
                    orderlines = self.get('orderLines').models;
                }

                for (var i = 0; i < orderlines.length; i++) {
                    var _line = orderlines[i];
                    if (_line && _line.can_be_merged_with(line) && options.merge !== false) {
                        _line.merge(line);
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    this.get('orderLines').add(line);
                }
                this.selectLine(this.getLastOrderline());

            }


        },
        addPaymentline: function (cashregister) {

            //if (this.get_remaining() === 0) {
            //    return
            //}
            var paymentLines = this.get('paymentLines');
            var newPaymentline = new module.Paymentline({}, {cashregister: cashregister, pos: this.pos});
            if (cashregister.journal.type !== 'cash') {
                newPaymentline.set_amount(Math.max(this.getDueLeft(), 0));
            }
            paymentLines.add(newPaymentline);
            this.selectPaymentline(newPaymentline);


        },
        export_as_JSON: function () {
            var orderLines, paymentLines;
            var type = false;
            var refund_order_id = false;
            orderLines = [];
            (this.get('orderLines')).each(_.bind(function (item) {
                return orderLines.push([0, 0, item.export_as_JSON()]);
            }, this));
            paymentLines = [];
            (this.get('paymentLines')).each(_.bind(function (item) {
                return paymentLines.push([0, 0, item.export_as_JSON()]);
            }, this));

            if (this.has("type") && this.has("refund_order_id")) {
                type = this.get("type");
                refund_order_id = this.get("refund_order_id");
            }

            if (self) {
            }

            return {
                name: this.getName(),
                amount_paid: this.getPaidTotal(),
                amount_total: this.getTotalTaxIncluded(),
                amount_tax: this.getTax(),
                amount_return: this.getChange(),
                lines: orderLines,
                statement_ids: paymentLines,
                pos_session_id: this.pos.pos_session.id,
                partner_id: this.get_client() ? this.get_client().id : false,
                user_id: this.pos.cashier ? this.pos.cashier.id : this.pos.user.id,
                uid: this.uid,
                sequence_number: this.sequence_number,
                type: type,
                refund_order_id: refund_order_id,
                credit_paid: this.get("credit_paid"),
                get_credit_note_ncf: this.get("credit_note_ncf")
            };
        }
    });

    module.Orderline = module.Orderline.extend({
        initialize: function (attr, options) {
            this._super('initialize', attr, options);
            this.manuel_price = false;
            this.note = this.note || "";

            if (options.product !== undefined && options.order !== null) {
                var qty = this.compute_qty(options.order, options.product);
                var partner = options.order.get_client();
                var product = options.product;
                var db = this.pos.db;
                var price = this.pos.pricelist_engine.compute_price_all(db, product, partner, qty);
                if (price !== false && price !== 0.0) {
                    this.price = price;
                }
            }
        },
        set_manuel_price: function (state) {
            this.manuel_price = state;
        },
        set_quantity: function (quantity) {
            this._super('set_quantity', quantity);
            var partner = this.order.get_client();
            var product = this.product;
            var db = this.pos.db;
            var price = this.pos.pricelist_engine.compute_price_all(db, product, partner, quantity);
            if (price !== false && price !== 0.0) {
                this.price = price;
            }
            this.trigger('change', this);
        },
        get_all_prices: function () {

            var self = this;
            var currency_rounding = this.pos.currency.rounding;
            var base = this.get_base_price();
            var totalTax = base;
            var totalNoTax = base;
            var product = this.get_product();
            var taxes = this.get_applicable_taxes();
            var taxtotal = 0;
            var taxdetail = {};

            // Add by pos_pricelist
            var partner = this.order.get_client();
            var fiscal_position_taxes = [];
            if (partner && partner.property_account_position) {
                fiscal_position_taxes = self.pos.db.find_taxes_by_fiscal_position_id(partner.property_account_position[0]);
            }
            var product_taxes = [];
            for (var i = 0, ilen = fiscal_position_taxes.length; i < ilen; i++) {
                var fp_tax = fiscal_position_taxes[i];
                for (var j = 0, jlen = taxes.length; j < jlen; j++) {
                    var p_tax = taxes[j];
                    if (fp_tax && p_tax && fp_tax.tax_src_id[0] === p_tax.id) {
                        var dest_tax = _.detect(this.pos.taxes, function (t) {
                            return t.id === fp_tax.tax_dest_id[0];
                        });
                        product_taxes.push(dest_tax);
                    }
                }
            }
            if (product_taxes.length === 0) {
                for (var i = 0, ilen = product.taxes_id.length; i < ilen; i++) {
                    var _id = product.taxes_id[i];
                    var p_tax = _.detect(this.pos.taxes, function (t) {
                        return t.id === _id;
                    });
                    product_taxes.push(p_tax);
                }
            }
            _.each(product_taxes, function (tax) {
                if (tax.price_include) {
                    var tmp;
                    if (tax.type === "percent") {
                        tmp = base - round_pr(base / (1 + tax.amount), currency_rounding);
                    } else if (tax.type === "fixed") {
                        tmp = round_pr(tax.amount * self.get_quantity(), currency_rounding);
                    } else {
                        throw "This type of tax is not supported by the point of sale: " + tax.type;
                    }
                    tmp = round_pr(tmp, currency_rounding);
                    taxtotal += tmp;
                    totalNoTax -= tmp;
                    taxdetail[tax.id] = tmp;
                } else {
                    var tmp;
                    if (tax.type === "percent") {
                        tmp = tax.amount * base;
                    } else if (tax.type === "fixed") {
                        tmp = tax.amount * self.get_quantity();
                    } else {
                        throw "This type of tax is not supported by the point of sale: " + tax.type;
                    }
                    tmp = round_pr(tmp, currency_rounding);
                    if (tax.include_base_amount) {
                        base += tmp;
                    }
                    taxtotal += tmp;
                    totalTax += tmp;
                    taxdetail[tax.id] = tmp;
                }
            });
            return {
                "priceWithTax": totalTax,
                "priceWithoutTax": totalNoTax,
                "tax": taxtotal,
                "taxDetails": taxdetail
            };
        },
        can_be_merged_with: function (orderline) {
            var result = this._super('can_be_merged_with', orderline);
            if (orderline.get_note() !== this.get_note()) {
                return false;
            } else {
                if (!result) {
                    if (!this.manuel_price) {
                        return (this.get_product().id === orderline.get_product().id);
                    } else {
                        return false;
                    }
                }
                return true;
            }
        },
        merge: function (orderline) {
            this._super('merge', orderline);
            this.set_unit_price(orderline.price);
        },
        compute_qty: function (order, product) {
            var qty = 1;
            var orderlines = [];
            if (order !== null) {
                if (order.get('orderLines').models !== undefined) {
                    orderlines = order.get('orderLines').models;
                }
            }

            for (var i = 0; i < orderlines.length; i++) {
                if (orderlines[i].product.id === product.id && !orderlines[i].manuel_price) {
                    qty += orderlines[i].quantity;
                }
            }
            return qty;
        },
        set_note: function (note) {
            this.set('note', note)
        },
        get_note: function () {
            return this.get('note');
        },
        set_discount: function (discount) {
            var self = this;
            var can_discount = self.validate_discount(discount);
            if (can_discount) {
                var disc = Math.min(Math.max(parseFloat(discount) || 0, 0), 100);
                this.discount = disc;
                this.discountStr = '' + disc;
                this.trigger('change', this);
            }
        },
        validate_discount: function (discount) {

            var self = this;
            var amount_list = [];
            self.pos.validate_manager();
            var currentOrder = self.pos.get('selectedOrder');
            var load_order = false;
            if (currentOrder.has("load_order")) {
                if (currentOrder.get("load_order") === true) {
                    load_order = true;
                    currentOrder.set("load_order", false)
                }
            }
            if (self.pos.manger_validated) {
                var max_disc = 0;
                amount_list.push(self.pos.manger_permission.max_disc);

                if (amount_list.length > 1) {
                    max_disc = _.max(amount_list);
                } else {
                    max_disc = amount_list[0]
                }
                var msg = "";
                if (max_disc) {
                    msg = 'Usted no esta autorizado a dar descuentos de mas de un ' + max_disc.toString() + "% !"
                } else {
                    msg = "Usted no esta autorizado a dar descuentos!"
                }

                if (load_order) {
                    return true
                } else if (discount <= max_disc) {
                    return true
                } else {
                    self.pos.pos_widget.screen_selector.show_popup('error', {
                        'message': _t('Descuento rechazado'),
                        'comment': _t(msg)
                    });
                    return;
                }

            } else {
                return false
            }

        },
        set_note: function (note) {
            this.note = note;
            this.trigger('change', this);
        },
        get_note: function (note) {
            return this.note;
        },
        clone: function () {
            var self = this;
            var orderline = self.clone.call(this);
            orderline.note = this.note;
            return orderline;
        },
        export_as_JSON: function () {
            return {
                qty: this.get_quantity(),
                price_unit: this.get_unit_price(),
                discount: this.get_discount(),
                product_id: this.get_product().id,
                origin_id: this.get_product().origin_id,
                note: this.get_note()
            };
        }
    });

    /**
     * Pricelist Engine to compute price
     */
    module.PricelistEngine = instance.web.Class.extend({
        init: function (options) {
            options = options || {};
            this.pos = options.pos;
            this.db = options.db;
            this.pos_widget = options.pos_widget;
        },
        /**
         * compute price for all price list
         * @param db
         * @param product
         * @param partner
         * @param qty
         * @returns {*}
         */
        compute_price_all: function (db, product, partner, qty) {
            var price_list_id = false;
            if (partner && partner.property_product_pricelist) {
                price_list_id = partner.property_product_pricelist[0];
            } else {
                price_list_id = db.default_pricelist_id;
            }
            return this.compute_price(db, product, partner, qty, parseInt(price_list_id));
        },
        /**
         * loop find a valid version for the price list id given in param
         * @param db
         * @param pricelist_id
         * @returns {boolean}
         */
        find_valid_pricelist_version: function (db, pricelist_id) {
            var date = new Date();
            var version = false;
            var pricelist = db.pricelist_by_id[pricelist_id];
            for (var i = 0, len = pricelist.version_id.length; i < len; i++) {
                var v = db.pricelist_version_by_id[pricelist.version_id[i]];
                if (((v.date_start == false) || (new Date(v.date_start) <= date)) &&
                    ((v.date_end == false) || (new Date(v.date_end) >= date))) {
                    version = v;
                    break;
                }
            }
            return version;
        },
        /**
         * compute the price for the given product
         * @param database
         * @param product
         * @param partner
         * @param qty
         * @param pricelist_id
         * @returns {boolean}
         */
        compute_price: function (database, product, partner, qty, pricelist_id) {

            var self = this;
            var db = database;

            // get a valid version
            var version = this.find_valid_pricelist_version(db, pricelist_id);
            if (version == false) {
                var message = _t('Pricelist Error');
                var comment = _t('At least one pricelist has no active version ! Please create or activate one.');
                show_error(this, message, comment);
                return false;
            }

            // get categories
            var categ_ids = [];
            if (product.categ_id) {
                categ_ids.push(product.categ_id[0]);
                categ_ids = categ_ids.concat(db.product_category_ancestors[product.categ_id[0]]);
            }

            // find items
            var items = [], i, len;
            for (i = 0, len = db.pricelist_item_sorted.length; i < len; i++) {
                var item = db.pricelist_item_sorted[i];
                if ((item.product_id === false || item.product_id[0] === product.id) &&
                    (item.categ_id === false || categ_ids.indexOf(item.categ_id[0]) !== -1) &&
                    (item.price_version_id[0] === version.id)) {
                    items.push(item);
                }
            }

            var results = {};
            results[product.id] = 0.0;
            var price_types = {};
            var price = false;

            // loop through items
            for (i = 0, len = items.length; i < len; i++) {
                var rule = items[i];

                if (rule.min_quantity && qty < rule.min_quantity) {
                    continue;
                }
                if (rule.product_id && rule.product_id[0] && product.id != rule.product_id[0]) {
                    continue;
                }
                if (rule.categ_id) {
                    var cat_id = product.categ_id[0];
                    while (cat_id) {
                        if (cat_id == rule.categ_id[0]) {
                            break;
                        }
                        cat_id = db.product_category_by_id[cat_id].parent_id[0];
                    }
                    if (!(cat_id)) {
                        continue;
                    }
                }
                // Based on field
                switch (rule.base) {
                    case -1:
                        if (rule.base_pricelist_id) {
                            price = self.compute_price(db, product, false, qty, rule.base_pricelist_id[0]);
                        }
                        break;
                    case -2:
                        var seller = false;
                        for (var index in product.seller_ids) {
                            var seller_id = product.seller_ids[index];
                            var _tmp_seller = db.supplierinfo_by_id[seller_id];
                            if ((!partner) || (_tmp_seller.name.length && _tmp_seller.name[0] != partner.name))
                                continue;
                            seller = _tmp_seller
                        }
                        if (!seller && product.seller_ids) {
                            seller = db.supplierinfo_by_id[product.seller_ids[0]];
                        }
                        if (seller) {
                            for (var _id in seller.pricelist_ids) {
                                var info_id = seller.pricelist_ids[_id];
                                var line = db.pricelist_partnerinfo_by_id[info_id];
                                if (line.min_quantity <= qty) {
                                    price = line.price
                                }
                            }
                        }
                        break;
                    default:
                        if (!price_types.hasOwnProperty(rule.base)) {
                            price_types[rule.base] = db.product_price_type_by_id[rule.base];
                        }
                        var price_type = price_types[rule.base];
                        if (db.product_by_id[product.id].hasOwnProperty(price_type.field)) {
                            price = db.product_by_id[product.id][price_type.field];
                        }
                }
                if (price !== false) {
                    var price_limit = price;
                    price = price * (1.0 + (rule['price_discount'] ? rule['price_discount'] : 0.0))
                    if (rule['price_round']) {
                        price = parseFloat(price.toFixed(Math.ceil(Math.log(1.0 / rule['price_round']) / Math.log(10))));
                    }
                    price += (rule['price_surcharge'] ? rule['price_surcharge'] : 0.0);
                    if (rule['price_min_margin']) {
                        price = Math.max(price, price_limit + rule['price_min_margin'])
                    }
                    if (rule['price_max_margin']) {
                        price = Math.min(price, price_limit + rule['price_min_margin'])
                    }
                }
                break;
            }
            return price
        },
        /**
         * @param partner
         */
        update_products_ui: function (partner) {
            var db = this.db;
            if (!this.pos_widget.product_screen) return;
            var product_list_ui = this.pos_widget.product_screen.$('.product-list span.product');
            for (var i = 0, len = product_list_ui.length; i < len; i++) {
                var product_ui = product_list_ui[i];
                var product_id = $(product_ui).data('product-id');
                var product = db.get_product_by_id(product_id);
                var price = this.compute_price_all(db, product, partner, 1);
                if (price !== false && price !== 0.0) {
                    price = round_di(parseFloat(price) || 0, this.pos.dp['Product Price']);
                    price = this.pos_widget.format_currency(price);
                    $(product_ui).find('.price-tag').html(price);
                }
            }
        },
        /**
         *
         * @param partner
         * @param orderLines
         */
        update_ticket: function (partner, orderLines) {
            var db = this.db;
            for (var i = 0, len = orderLines.length; i < len; i++) {
                var line = orderLines[i];
                var product = line.product;
                var quantity = line.quantity;
                var price = this.compute_price_all(db, product, partner, quantity);
                if (price !== false && price !== 0.0) {
                    line.price = price;
                }
                line.trigger('change', line);
            }
        }
    });

    function show_error(context, message, comment) {
        context.pos.pos_widget.screen_selector.show_popup('error', {
            'message': message,
            'comment': comment
        });
    }

    function arrange_elements(pos_model) {

        var product_model = pos_model.find_model('product.product');
        if (_.size(product_model) == 1) {
            var product_index = parseInt(Object.keys(product_model)[0]);
            pos_model.models[product_index].fields.push('categ_id', 'seller_ids');
        }

        var res_product_pricelist = pos_model.find_model('product.pricelist');
        if (_.size(res_product_pricelist) == 1) {
            var pricelist_index = parseInt(Object.keys(res_product_pricelist)[0]);
            pos_model.models.splice(++pricelist_index, 0,
                {
                    model: 'account.fiscal.position.tax',
                    fields: ['display_name', 'position_id', 'tax_src_id', 'tax_dest_id'],
                    domain: null,
                    loaded: function (self, fiscal_position_taxes) {
                        self.db.add_fiscal_position_taxes(fiscal_position_taxes);
                    }
                },
                {
                    model: 'pricelist.partnerinfo',
                    fields: ['display_name', 'min_quantity', 'name', 'price', 'suppinfo_id'],
                    domain: null,
                    loaded: function (self, pricelist_partnerinfos) {
                        self.db.add_pricelist_partnerinfo(pricelist_partnerinfos);
                    }
                },
                {
                    model: 'product.supplierinfo',
                    fields: ['delay', 'name', 'min_qty', 'pricelist_ids', 'product_code', 'product_name', 'sequence',
                        'qty', 'product_tmpl_id'],
                    domain: null,
                    loaded: function (self, supplierinfos) {
                        self.db.add_supplierinfo(supplierinfos);
                    }
                },
                {
                    model: 'product.category',
                    fields: ['name', 'display_name', 'parent_id', 'child_id'],
                    domain: null,
                    loaded: function (self, categories) {
                        self.db.add_product_categories(categories);

                    }
                },
                {
                    model: 'ir.model.data',
                    fields: ['res_id'],
                    domain: function () {
                        return [
                            ['module', '=', 'product'],
                            ['name', '=', 'property_product_pricelist']
                        ]
                    },
                    loaded: function (self, res) {
                        self.db.add_default_pricelist(res);
                    }
                },
                {
                    model: 'product.pricelist',
                    fields: ['display_name', 'name', 'version_id', 'currency_id'],
                    domain: function () {
                        return [
                            ['type', '=', 'sale']
                        ]
                    },
                    loaded: function (self, pricelists) {
                        self.db.add_pricelists(pricelists);
                    }
                },
                {
                    model: 'product.pricelist.version',
                    fields: ['name', 'pricelist_id', 'date_start', 'date_end', 'items'],
                    domain: null,
                    loaded: function (self, versions) {
                        self.db.add_pricelist_versions(versions);
                    }
                },
                {
                    model: 'product.pricelist.item',
                    fields: ['name', 'base', 'base_pricelist_id', 'categ_id', 'min_quantity',
                        'price_discount', 'price_max_margin', 'price_min_margin', 'price_round', 'price_surcharge',
                        'price_version_id', 'product_id', 'product_tmpl_id', 'sequence'
                    ],
                    domain: null,
                    loaded: function (self, items) {
                        self.db.add_pricelist_items(items);
                    }
                },
                {
                    model: 'product.price.type',
                    fields: ['name', 'field', 'currency_id'],
                    domain: null,
                    loaded: function (self, price_types) {
                        // we need to add price type field to product.product model if not the case
                        var product_model = posmodel.find_model('product.product');
                        for (var i = 0, len = price_types.length; i < len; i++) {
                            var p_type = price_types[i].field;
                            if (_.size(product_model) == 1) {
                                var product_index = parseInt(Object.keys(product_model)[0]);
                                if (posmodel.models[product_index].fields.indexOf(p_type) === -1) {
                                    posmodel.models[product_index].fields.push(p_type);
                                }
                            }
                        }
                        self.db.add_price_types(price_types);
                    }
                }
            );
        }

        var res_partner_model = pos_model.find_model('res.partner');
        if (_.size(res_partner_model) == 1) {
            var res_partner_index = parseInt(Object.keys(res_partner_model)[0]);
            pos_model.models[res_partner_index].fields.push('property_account_position', 'property_product_pricelist');
        }

    }

}
